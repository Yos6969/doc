

# TCP

##TCP状态转移

![26](C:\Users\18181\Desktop\doc\repo\img\26.png)

![image](.\img\queueintcppng)

## TCP协议格式

![](./img/tcp-header.jpg)

- 端口号：tcp使用端口号来标记目标和源端口，tcp头中并没有ip地址信息，根据前面的tcp/ip模型，ip地址这是三层做的事情。
- 序号（Sequence Number）：用于对tcp字节流进行编号，以解决网络包乱序问题。
- 确认号（Acknowledgement Number）：用于确认接收到的报文段序号，用来解决丢包问题。
- 窗口：用于通知对端接收窗口大小，用于解决流控问题。
- TCP标志位，用于控制TCP协议状态机的，包括以下几个：
  - ACK：只有这个标志位置位时，前面的确认号字段才有效。
  - SYN：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
  - FIN：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
  - RST：重置连接，比如向一个不存在监听服务的端口发请求时，就会收到RST包。
- TCP选项：这部分可选，不属于TCP头部必然存在的部分。
  - MSS（Maximum Segment Size，最大报文长度）：MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以一般MSS值1460。

## 三次握手

  1.客户端发起第一次握手(SYN=1, seq=x)

  2.服务器端发起第二次握手(SYN=1, seq=y, ACKnum=x+1)

  3.客户端发起第三次握手(ACKnum=y+1)

**为什么不是两次握手？**

如果你细读[RFC793](https://link.zhihu.com/?target=https%3A//www.ietf.org/rfc/rfc793.txt)，也就是 TCP 的协议 RFC，你就会发现里面就讲到了为什么三次握手是必须的——TCP 需要 seq [序列号](https://www.zhihu.com/search?q=序列号&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A573627478})来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。

四次挥手

1. 想要拆除连接的一方A发送FIN报文，自身进入到FIN_WAIT_1状态；
2. 被拆除连接的一方B接收到FIN报文，发ACK，自身进入到CLOSE_WAIT状态；
3. A收到ACK，进入FIN_WAIT_2状态;
4. B发送FIN，自身进入LAST_ACK状态；
5. A收到FIN，发送ACK，自身进入TIME_WAIT状态；
6. B收到ACK报文，B上的这个socket关闭，端口释放；
7. A等待2MSL后socket关闭，释放端口。

**为什么四次挥手？**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

## 2MSL等待状态

TIME_WAIT状态也称为2 MSL等待状态。每个具体 TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。 我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制 其生存时间的TTL字段。

```
TIME_WAIT状态的作用主要有两个：

1.避免拆链报文在链路中丢失造成连接关闭异常：在第6步，B没有收到ACK报文的时候会认为A没有收到FIN包，进而会重传第4步的FIN，如果这个时候没有TIME_WAIT状态，A侧socket已经关闭，A会针对B发送的FIN包响应RST，有可能导致B连接异常。
2.避免乱序到来的业务报文在新生成的socket连接中引发混乱：假设在拆链前有TCP报文由于中间网络传输原因导致在第7步完成之后才到达，如果没有TIME_WAIT状态而A和B又使用同样的4元组新建了一个新的socket，那么迷路的数据包就会进入到新的socket中进行处理，可能导致业务异常。
```



 T C P连接在2 M S L等待期间，定义这个连接的插口 （客户的I P地址和端口号，服务器的 I P地址和端口号）不能再被使用。这个连接只能在 2 M S L 结束后才能再被使用。

## TCP和UDP的区别

```
1.TCP是面向连接的传输协议，传输数据之前必须先建立好连接。UDP是属于无连接的传输协议
2.TCP是点对点的两点之间的服务，一条TCP连接只能有两个端点,UDP支持一对一、一对多、多对一、多对多的交互通信
3.TCP是可靠的传输协议，进行的是可靠交付，即无差错、不丢失、不重复、按序到达等.UDP是不可靠的传输协议，只是尽最大努力交付，不能保证可靠交付
4.TCP有拥塞控制和流量控制保证数据传输的安全性。UDP没有拥塞控制，当网络拥塞时不会影响源主机的发送效率
5.TCP首部开销大，因为首部就占了20个字节。UDP首部开销相对小一点，只占了8个字节。 （eg: UDP的8个字节分布在：源端口、目的端口、数据长度、校验和）
```

# 粘包

当时短连接的情况下，不用考虑粘包的情况
如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包
如果双方建立长连接，需要在连接后一段时间内发送不同结构数据
发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
等等。

## 流量控制

TCP为它的应用程序提供了流量控制服务（flow control service），以消除发送方使接收方数据溢出的可能性。

流量控制因此是一种速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。

另一种控制发送方速度的方式是拥塞控制（congestion control），但是这两者是不同的：

- 流量控制基于对端的窗口大小来调整发送方的发送速度。
- 拥塞控制基于IP网络的速度来调整发送方的发送策略。

下一节分析拥塞控制，这一节分析流量控制。

TCP让发送方维持一个接收窗口（receive window）的变量来提供流量控制。接收窗口用于给发送方一个提示，该接收方还有多少可用的缓存空间。因为TCP是全双工通信，因此在连接两端都各自维护一个接收窗口，通过TCP头的window字段来通知对方本方的接收窗口大小。

### 滑动窗口

client和server两端都有自己的协议栈buffer，传输时不可能一直无限量的传输数据下去。此时如何让对端知道自己最多能接收多少数据呢？通过TCP协议头中的window字段来通知对端自己当前的接收窗口大小。

从以上可以看出，TCP协议通过TCP头部的window字段来解决流量控制问题。

![](./img/tcpwindows.png)

如上图中，分成了四个部分，其中黑色框住的部分是滑动窗口：

- \#1：表示已收到ack报文确认的数据。
- \#2：发送出去但是还没有收到对端ACK确认的数据。
- \#3：还没有发送出去的数据。
- \#4：窗口以外的数据。

## 拥塞控制

##长连接和短连接

```
长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。  

连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）； 
这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态；

TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。

```

```
短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；

连接→数据传输→关闭连接；
```

长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多的情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

   而像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

# DNS

DNS 的全称是 Domain Name System 或者 Domain Name Service，它主要的作用就是将人们所熟悉的网址 (域名) “翻译”成电脑可以理解的 IP 地址，这个过程叫做 DNS 域名解析。

DNS占用udp和tcp的53端口，一般来说，DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。

## 输入url后的解析过程

```
1.根据域名，进行DNS域名解析；
2.拿到解析的IP地址，建立TCP连接；
3.向IP地址，发送HTTP请求；
4.服务器处理请求；
5.返回响应结果；
6.关闭TCP连接；
7.浏览器解析HTML；
8.浏览器布局渲染；
```

# HTTP和HTTPS

http的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作,是专门用来传输注入HTML的超媒体文档等web内容的协议,它是基于传输层的TCP协议的应用层协议

https:https是基于安全套接字的http协议,也可以理解为是http+ssl/tls(数字证书)的组合

```
http和https的区别:
HTTP的URL以 http://开头，而 HTTPS 的 URL 以 https:// 开头
HTTP是不安全的，而HTTPS是安全的
HTTP标准端口是 80 ，而HTTPS的标准端口是 443
在OSI网络模型中，HTTPS的加密是在传输层完成的,因为SSL是位于传输层的,TLS的前身是SSL,所以同理
HTTP无需认证证书,而https需要认证证书 
```

## HTTPS工作原理

```
HTTPS工作原理
1.服务端给客户端传输证书,这个证书就是公钥,包含证书的办法机构,证书的过期时间等信息
2.客户端进行证书的解析,如验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端
3.服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信
4.服务端将消息进行对称加密(消息和私钥进行混合,除非知道私钥否则无法进行解密),私钥正好只有客户端和服务端知道,服务端将进行对称加密后的消息进行传送客户端使用私钥进行信息的解密
```

##常用的HTTP方法

```
GET 从服务器获得资源

POST 客户端向服务器提交资源

PUT 修改服务器相关资源

DELETE 删除服务器相关资源
```

## HTTP状态码

```
2xx : 代表服务端已经成功接收并处理了该请求
200:服务端成功接收了该请求并进行了处理,请求所需要的数据应该伴随这次请求对应的响应返回给客户端
202:服务端已经成功接收了请求,但是并未进行处理
3xx : 通常代表客户端需要进行进一步请求用,常用来进行重定向的状态码
301: 客户端请求的资源已经永久移动到别的位置,服务端会自动将该请求重定向到新的位置
4xx : 通常表示客户端请求有问题
401 : 需要用户进行登录
403 : 服务端收到请求,但是拒绝进行处理
404 : 访问的资源不存在
5xx : 通常表示服务端内部错误
500 : 服务端代码出错
502 : 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
503:  服务器正在维护或者访问过载,过一段时间可能恢复正常
504 : 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应 
```

##Get与Post的区别

Get方式是从服务器上获取数据；在做数据查询时，建议用Get方式；如：商品信息接口、搜索接口、博客访客接口等。

Post方式是向服务器传送数据 ；在做数据添加、修改或删除时，建议用Post方式 ；如：微博图片上传图片接口、登录注册接口等。

```
1) get参数通过url传递，post放在request body中。

2) get请求在url中传递的参数是有长度限制的，而post没有。

3) get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。

4) get请求只能进行url编码，而post支持多种编码方式

5) get请求会浏览器主动cache，而post支持多种编码方式。

6) get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
```



# 杂项



##DHCP-动态主机设置协议

https://www.cnblogs.com/easonscx/p/10724742.html



##网络通信元组

```
四元组：源IP地址，源端口，目的IP地址，目的端口
五元组：源IP地址，源端口，目的IP地址，目的端口和传输层协议
七元组：源IP地址，源端口，目的IP地址，目的端口，传输层协议，服务类型，接口索引
```

# 示例代码

client.cpp

```c
#include	"unp.h"

int
main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_in	servaddr;

	if (argc != 2)
		err_quit("usage: tcpcli <IPaddress>");

	sockfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

	Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

	str_cli(stdin, sockfd);		/* do it all */

	exit(0);
}

```

```c
#include	"unp.h"

void
str_cli(FILE *fp, int sockfd)
{
	char	sendline[MAXLINE], recvline[MAXLINE];

	while (Fgets(sendline, MAXLINE, fp) != NULL) {

		Writen(sockfd, sendline, 1);
		sleep(1);
		Writen(sockfd, sendline+1, strlen(sendline)-1);

		if (Readline(sockfd, recvline, MAXLINE) == 0)
			err_quit("str_cli: server terminated prematurely");

		Fputs(recvline, stdout);
	}
}

```

server.cpp

```c
#include	"unp.h"

int
main(int argc, char **argv)
{
	int					listenfd, connfd;
	pid_t				childpid;
	socklen_t			clilen;
	struct sockaddr_in	cliaddr, servaddr;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);

	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

	Listen(listenfd, LISTENQ);

	for ( ; ; ) {
		clilen = sizeof(cliaddr);
		connfd = Accept(listenfd, (SA *) &cliaddr, &clilen);

		if ( (childpid = Fork()) == 0) {	/* child process */
			Close(listenfd);	/* close listening socket */
			str_echo(connfd);	/* process the request */
			exit(0);
		}
		Close(connfd);			/* parent closes connected socket */
	}
}

```



