

# QT项目

可以回答多线程同步

1. 运行在控制节点上的master，这个程序监视并控制整个机群的状态
2. 运行在每个计算节点的slave，负责监控资源的状态

master和每个slave之间用一个TCP连接，每个master采用2或4个IO线程来处理8个TCP connection，能有效降低延迟

master要异步地网本地硬盘写log，要求logging library有自己的IO线程

master有可能要独写数据库库，数据库的第三方library得有自己的线程

master要服务于多个clients，需要两个IO线程专门处理和clients的通信



消息队列的实现

4 无锁队列
对于消息队列可以采用有锁来实现，多线程操作有锁队列也会引起的问题：
1 同一个线程在不同cpu运行会发生切换 cache损坏(cache trashing)
2 在同步机制上争抢队列block_queue(mutex+condition)
3 动态分配内存(对于高性能队列，开辟释放内存，不是直接调用系统调用来实现，而是采用内存池来实现）


## 日志

在多线程程序中，前端和后端都与单线程程序无甚区别，无非是每个线程有自己的前端，整个程序共用一个后端。难点是要将日志数据从多个前端高效地传输到后端。这是一个典型的多生产者-单消费者问题



要给web写一个sigpip  handler  什么也不做

我的一个服务器程序, 在Windows下运行正常.

但当在Linux(centos 6.3)下,进行对端未开启的异常测试时,出现莫名退出 . 最后跟踪到是write调用导致退出. 用gdb执行程序, 退出时提示"Broken pipe".

 

问题分析：

对一个对端已经关闭的socket调用两次write, 第二次将会生成SIGPIPE信号, 该信号默认结束进程.

具体的分析可以结合TCP的”四次握手”关闭. TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP

协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, **因为TCP协议的限制, 一个端点无法获知对端已经完全关闭**.
