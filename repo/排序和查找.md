

# 排序

![image-20220315165721088](.\img\27.png)



## 冒泡排序

```c++
for(int i=0;i<nums.size();i++)
{
	for(int j=0;j<nums.size()-i-1;j++)
	{
		if(nums[i] > nums[i+j+1])
			swap(nums[i],nums[i+j+1]);
	}
}
```



##插入排序

每次选择一个元素，并且将这个元素和整个数组中的所有元素进行比较，然后插入到合适的位置，图片演示如上，时间复杂度 O(n^2)

![gif1](.\img\1.gif)

```c++
void insert_sort(vector<int>&vec) {
    int j, i;
    for (i = 1; i < vec.size(); i++) {
        int tmp=vec[i];
        for (j = i; j > 0 && vec[j - 1] > tmp; j--)
            vec[j] = vec[j - 1];
        vec[j]=tmp;
    }
}
```

##希尔排序

插入排序的修改版，根据步长由长到短分组，进行排序，直到步长为1为止，属于插入排序的一种。

![25](img\25.png)

```c++
void shell_sort(vector<int>&vec) {
    for(int gap=vec.size()/2;gap>0;gap/=2){
        for(int i=gap;i<vec.size();i++){
            for(j=i-gap;j>=0;j-=gap)
                if()
                vec[j]=vec[j-gap];          
        }
    }
}
```

##归并排序

![16](.\img\16.jpg)

##快排

非稳定排序

```c++
/*215. 数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 

提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104*/
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        
        quickSort(nums,0,nums.size()-1,k);
        return nums[nums.size()-k];
    }
    void quickSort(vector<int>&nums,int left,int right,int k){
        if(left>=right)
            return;
        
        int i=left;
        
        int j=right;
        while(i<j){
            while(i<j&&nums[j]>=nums[left])j--;

            while(i<j&&nums[i]<=nums[left])i++;
            
            swap(nums[i],nums[j]);
        }
        swap(nums[i],nums[left]);
       //找到第k大直接退出排序
        if(i==nums.size()-k)
            return ;


        quickSort(nums, left, i-1,k);
        quickSort(nums, i+1, right,k);
        
    }
};
```

##桶排序

桶排序时间复杂度O(n),空间复杂度O(n)。稳定排序。

```c++
/*给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]

提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的

进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。*/
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int , int>hash;
        int maxcnt=0;
        for(auto &i:nums){
            hash[i]++;
            maxcnt=max(maxcnt,hash[i]);
        }
        vector<vector<int>>buckets(maxcnt+1);
        for(auto &i:hash){
            buckets[i.second].push_back(i.first);
        }
        vector<int>ans;
        int current=maxcnt;
        for (int i = current; i >= 0; i--) {
            // k 为 0 表示，已经都找到
            if (k == 0) break;
            // 如果当前频率的桶为空，则跳过
            if (!buckets[i].size()) continue;
            // 不为空则要加入把桶内元素加入 res 数组, 使要找的频率 k--
            for (int j = 0; j < buckets[i].size(); j++) {
                int number = buckets[i][j];
                ans.push_back(number);
                k--;
            }
        }

        return ans;
        
    }
};
```

## 计数排序

首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。

### 荷兰国旗问题

直接统计数量，然后重排数组，时间空间复杂度都是o(n+k)

![img](.\img\countSort.png)

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        vector<int> color(3);
        for (int i = 0; i < nums.size(); i++)
        {
            color[nums[i]]++; 
        }

        int k = 0;
        for (int j = 0; j < color.size(); j++)
        {
            while (color[j] != 0)
            {
                color[j]--;
                nums[k++] = j;
            }
        }
    }
};
```



##堆排序

堆排序时间复杂度O(nlgn),空间复杂度O(1)。不稳定排序。

```c++
/*215. 数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 

提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104*/
```

# 查找

![image-20220315165853302](.\img\28.png)
