

# 插入排序

每次选择一个元素，并且将这个元素和整个数组中的所有元素进行比较，然后插入到合适的位置，图片演示如上，时间复杂度 O(n^2)

![gif1](.\img\1.gif)

```c++
void insert_sort(vector<int>&vec) {
    int j, i;
    for (i = 1; i < vec.size(); i++) {
        int tmp=vec[i];
        for (j = i; j > 0 && vec[j - 1] > tmp; j--)
            vec[j] = vec[j - 1];
        vec[j]=tmp;
    }
}
```



# 希尔排序

插入排序的修改版，根据步长由长到短分组，进行排序，直到步长为1为止，属于插入排序的一种。

![25](/img\25.png)

```c++
void shell_sort(vector<int>&vec) {
    for(int gap=vec.size()/2;gap>0;gap/=2){
        for(int i=gap;i<vec.size();i++){
            int temp=vec[i];
            int j;
            for(j=i;j>=gap&&vec[j-gap]>temp;j-=gap)
                vec[j]=vec[j-gap];
            vec[j]=temp;
        }
    }
}
```

# 归并排序

![16](.\img\16.jpg)

# 快排

非稳定排序

```c++
/*215. 数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 

提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104*/
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        
        quickSort(nums,0,nums.size()-1,k);
        return nums[nums.size()-k];
    }
    void quickSort(vector<int>&nums,int left,int right,int k){
        if(left>=right)
            return;
        
        int i=left;
        
        int j=right;
        while(i<j){
            while(i<j&&nums[j]>=nums[left])j--;

            while(i<j&&nums[i]<=nums[left])i++;
            
            swap(nums[i],nums[j]);
        }
        swap(nums[i],nums[left]);
       //找到第k大直接退出排序
        if(i==nums.size()-k)
            return ;


        quickSort(nums, left, i-1,k);
        quickSort(nums, i+1, right,k);
        
    }
};
```



#桶排序

桶排序时间复杂度O(n),空间复杂度O(n)。稳定排序。

```c++
/*给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]

提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的

进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。*/
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int , int>hash;
        int maxcnt=0;
        for(auto &i:nums){
            hash[i]++;
            maxcnt=max(maxcnt,hash[i]);
        }
        vector<vector<int>>buckets(maxcnt+1);
        for(auto &i:hash){
            buckets[i.second].push_back(i.first);
        }
        vector<int>ans;
        int current=maxcnt;
        for (int i = current; i >= 0; i--) {
            // k 为 0 表示，已经都找到
            if (k == 0) break;
            // 如果当前频率的桶为空，则跳过
            if (!buckets[i].size()) continue;
            // 不为空则要加入把桶内元素加入 res 数组, 使要找的频率 k--
            for (int j = 0; j < buckets[i].size(); j++) {
                int number = buckets[i][j];
                ans.push_back(number);
                k--;
            }
        }

        return ans;
        
    }
};
```








# 堆排序

堆排序时间复杂度O(nlgn),空间复杂度O(1)。不稳定排序。

```c++
/*215. 数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 

提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104*/
```

