# 栈和队列

1、栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

2、栈是先进后出，队列是先进先出。

3、栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。

# 树

## 二叉树

二叉树（Binary Tree）是指每个节点最多只有两个分支的树结构

### 二叉搜索/查找树

一棵空树或者满足以下性质的二叉树被称之为二叉查找树（Binary Search Tree）也被称为二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree）等。

(1)如果任意节点的左子树不为空，并且左子树上所有节点的值均小于它的根节点的值；

(2)如果任意节点的右子树不为空，并且右子树上所有节点的值均大于或等于它的根节点的值；

(3)任意节点的左、右子树分别为二叉查找树。

二叉查找树中查找的运行时间与树T的高度成正比。因为有n个结点的树的高度小则为O(logn)，大则为O(n).；

对于有n个关键字元素的数据项，高度为h的二叉查找树T，空间复杂度为O(n)；其中，查找元素，插入元素，删除元素的时间复杂度均为O(h)；

### 平衡树(AVL树)

所谓的平衡树是指一种改进的二叉查找树，顾名思义平衡树就是将二叉查找树平衡均匀地分布，这样的好处就是可以减少二叉查找树的深度。

一般情况下二叉查找树的查询复杂度取决于目标节点到树根的距离（即深度），当节点的深度普遍较大时，查询的平均复杂度就会上升，因此为了实现更高效的查询就有了平衡树。

非平衡二叉树(左)和平衡二叉树(右)如下图所示：

![14](C:/Users/18181/Desktop/doc/repo/img/14.png)

### 红黑树

红黑树除了具备二叉查找树的基本特性之外，还具备以下特性：

(1)    节点是红色或黑色；

(2)    根节点是黑色；

(3)    所有叶子都是黑色的空节点（NIL 节点）；

(4)    每个红色节点必须有两个黑色的子节点，也就是说从每个叶子到根的所有路径上，不能有两个连续的红色节点；

(5)    从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。

红黑树在查找方面和AVL树操作几乎相同。但是在插入和删除操作上，AVL树每次插入删除会进行大量的平衡度计算，红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能.

它的添加、删除以及查询数据的时间复杂度为 O(logn)。

![15](C:/Users/18181/Desktop/doc/repo/img/15.png)

哪些地方用到了红黑树？

- 红黑树用于进程调度 
- 内存管理的红黑树
-  nginx的共享内存
- epoll的红黑树 
- sk_buff使用的红黑树

# 表

## 哈希表--数组+链表

```c++
/*
 * @Author: your name
 * @Date: 2022-03-07 19:50:48
 * @LastEditTime: 2022-03-23 22:44:33
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /myinterview/hash.h
 */

#include<utility>
#include<vector>
using namespace std;
template<typename K,typename V>
class hashnode{
public:
   // hashnode():_pair(make_pair(key,value)),next(nullptr){}
   // hashnode(K key,V value):_pair(make_pair(key,value)),next(nullptr){}
    hashnode(std::pair<K,V> _pair):_pair(_pair),next(nullptr){}
    std::pair<K,V>& getpair(){
        return _pair;
    }
    hashnode* getnext(){
        return next;
    }
    void setnext( hashnode*_next){
        next=_next;
    }
private:
    std::pair<K,V> _pair;
    hashnode* next;
    
};

template<typename K,typename V,typename hashfunc>
class hashtable{
public:
    hashtable():hash_pair(vector<hashnode<K,V>*>(10,nullptr)),hash(){};

    ~hashtable(){
        for(int i=0;i<hash_pair.size();i++){
             hashnode<K,V> *cursor=hash_pair[i];
             hashnode<K,V> *next=nullptr;
             while(cursor){
                 next=cursor->getnext();
                 delete cursor;
                 cursor=next;
             }
             hash_pair[i]=nullptr;

        }
    }

    void insert(std::pair<K,V> pair){
       hashnode<K,V>*ptr=search(pair.first);
       if(ptr==nullptr){
           hash_pair[gethash(pair.first)%10]=new hashnode<K,V>(pair);
       }else if(ptr->getpair().first!=pair.first){//找到的是prev，执行插入
           ptr->setnext(new hashnode<K,V>(pair));
       }else if(ptr->getpair().first==pair.first){//找到的是cursor，执行更新
           ptr->getpair().second=pair.second;
       }
            
    }

    int erase(K key){
         hashnode<K,V>*ptr=search(key);
         if(ptr==nullptr||ptr->getpair().first!=key)//没有节点等于key
            return 0;
         else{
                hashnode<K,V> *cursor=hash_pair[gethash(key)%10];
                hashnode<K,V> *prev=nullptr;
                while(cursor){
                    if(cursor->getpair().first==key){//返回key值相同节点;
                        break;
                        }
                    else
                        { //记录前节点;
                            prev=cursor;
                            cursor=cursor->getnext();
                            }
                }
                    prev->setnext(cursor->getnext());
                    delete cursor;
                    return 1;
            } 
        }
        
    V& operator[](K key){
        hashnode<K,V>*ptr= search(key); 
        if(ptr->getpair().first==key){
            return ptr->getpair().second;
        }else if(ptr==nullptr){
            hashnode<K,V>*tmp=new hashnode<K,V>({key,V()});
            hash_pair[gethash(key)%10]=tmp;
            return tmp->getpair().second;
        }else{
            hashnode<K,V>*tmp=new hashnode<K,V>({key,V()});
            ptr->setnext(tmp);
            return tmp->getpair().second;
        }
    }


private:
    vector<hashnode<K,V>*>hash_pair;
    hashfunc hash;

    int gethash(K key){
        return  hash(key);
    }

    hashnode<K,V>* search(K key){
         int index=gethash(key)%10;
         if(hash_pair[index]==nullptr)
            {
                return nullptr;
            }
        else{
            hashnode<K,V> *cursor=hash_pair[index];
            hashnode<K,V> *prev=nullptr;
            while(cursor){
                    if(cursor->getpair().first==key){//返回key值相同节点;
                        return cursor;
                        }
                    else
                        { //记录前节点;
                            prev=cursor;
                            cursor=cursor->getnext();
                            }
                }
                return prev;
        }       
    }
};
//哈希函数
class hashfunc{
public:
    int  operator()(int a){
        return a*114514;
    }
};
```

# bitmap

```c++
class BitMap
{
public:
    BitMap(size_t num)
    {
        _v.resize((num >> 5) + 1); // 相当于num/32 + 1
    }

    void Set(size_t num) //set 1
    {
        size_t index = num >> 5; // 相当于num/32
        size_t pos = num % 32;
        _v[index] |= (1 << pos);
    }

    void ReSet(size_t num) //set 0
    {
        size_t index = num >> 5; // 相当于num/32
        size_t pos = num % 32;
        _v[index] &= ~(1 << pos);
    }

    bool HasExisted(size_t num)//check whether it exists
    {
        size_t index = num >> 5;
        size_t pos = num % 32;
        bool flag = false;
        if (_v[index] & (1 << pos))
            flag = true;
        return flag;

    }

private:
    vector<size_t> _v;
}; 
```

