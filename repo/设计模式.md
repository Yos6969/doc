# 单例

##有缺陷的懒汉式

```c++
template<typename T>
class Singleton{
private:
    Singleton(){
    }
    Singleton(Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static T* m_instance_ptr;
public:
    ~Singleton(){
    }
    static T* get_instance(){
        if(m_instance_ptr==nullptr){
              m_instance_ptr = new Singleton;
        }
        return m_instance_ptr;
    }
};

T* Singleton::m_instance_ptr = nullptr;
```

## 推荐的懒汉式单例

```c++
template<typename T>
class Singleton
{
public:
    static T& get_instance(){   
        return instance;
    }
private:
    static T instance;
    Singleton(){
    }
};
```



#工厂

## 简单工厂

```c++
#include <iostream>
using namespace std;

enum CarType{BENZ, BMW};

class Car//车类
{
public:
    virtual void createdCar(void) = 0;
};

class BenzCar : public Car //奔驰车
{
public:
    BenzCar()
    {
        cout<<"Benz::Benz()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BenzCar::createdCar()"<<endl;
    }
    ~BenzCar()
    {

    }
};

class BmwCar : public Car //宝马车
{
public:
    BmwCar()
    {
        cout<<"Bmw::Bmw()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BmwCar::createdCar()"<<endl;
    }
};


class CarFactory //车厂
{
public:
    Car* createSpecificCar(CarType type)
    {
        switch(type)
        {
        case BENZ://生产奔驰车
            return (new BenzCar());
            break;
        case BMW://生辰宝马车
            return (new BmwCar());
            break;
        default:
            return NULL;
            break;
        }
    }
};

int main(int argc, char** argv)
{
    CarFactory carfac;
    Car* specificCarA = carfac.createSpecificCar(BENZ);
    Car* specificCarB = carfac.createSpecificCar(BMW);   
    return 0;
}
```

## 工厂方法模式

不再只由一个工厂类决定那一个产品类应当被实例化,这个决定权被交给子类去做。当有新的产品（新型汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的方法来生成即可（新车型可以用一个新类继承创建产品即可），那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则。

```c++
#include <iostream>
using namespace std;

class Car//车类
{
public:
    virtual void createdCar(void) = 0;
};

class BenzCar : public Car //奔驰车
{
public:
    BenzCar()
    {
        cout<<"Benz::Benz()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BenzCar::createdCar()"<<endl;
    }
    ~BenzCar()
    {

    }
};

class BmwCar : public Car //宝马车
{
public:
    BmwCar()
    {
        cout<<"Bmw::Bmw()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BmwCar::createdCar()"<<endl;
    }
};


class Factory//车厂
{
public:
    virtual Car* createSpecificCar(void) = 0;
};

class BenzFactory : public Factory//奔驰车厂
{
public:
    virtual Car* createSpecificCar(void)
    {
        return (new BenzCar());
    }
};

class BmwFactory : public Factory//宝马车厂
{
public:
    virtual Car* createSpecificCar(void)
    {
        return (new BmwCar());
    }
};


int main(int argc, char** argv)
{
    Factory* factory = new BenzFactory();
    Car* specificCarA = factory->createSpecificCar();
    factory = new BmwFactory();
    Car* specificCarB = factory->createSpecificCar();    
    return 0;
}
```

## 抽象工厂

在上面的工厂方法模式基础上，有需要生产高配版的奔驰和宝马，那工厂方法模式就有点鞭长莫及了，这就又有抽象工厂模式

```c++
#include <iostream>
using namespace std;

class Car//车类
{
public:
    virtual void createdCar(void) = 0;
};

class BenzCar : public Car //奔驰车
{
public:
    BenzCar()
    {
        cout<<"Benz::Benz()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BenzCar::createdCar()"<<endl;
    }
    ~BenzCar()
    {

    }
};

class BmwCar : public Car //宝马车
{
public:
    BmwCar()
    {
        cout<<"Bmw::Bmw()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"BmwCar::createdCar()"<<endl;
    }
};

class HighCar //高配版车型
{
public:
    virtual void createdCar(void) = 0;
};

class HighBenzCar : public HighCar //高配奔驰车
{
public:
    HighBenzCar()
    {
        cout<<"HighBenzCarBenz::Benz()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"HighBenzCar::createdCar()"<<endl;
    }
};

class HighBmwCar : public HighCar //高配宝马车
{
public:
    HighBmwCar()
    {
        cout<<"HighBmwCar::Bmw()"<<endl;
    }
    virtual void createdCar(void)
    {
        cout<<"HighBmwCar::createdCar()"<<endl;
    }
};

class Factory//车厂
{
public:
    virtual Car* createSpecificCar(void) = 0;
    virtual HighCar* createdSpecificHighCar(void) = 0;
};

class BenzFactory : public Factory//奔驰车厂
{
public:
    virtual Car* createSpecificCar(void)
    {
        return (new BenzCar());
    }

    virtual HighCar* createdSpecificHighCar(void)
    {
        return (new HighBenzCar());
    }
};

class BmwFactory : public Factory//宝马车厂
{
public:
    virtual Car* createSpecificCar(void)
    {
        return (new BmwCar());
    }
    virtual HighCar* createdSpecificHighCar(void)
    {
        return (new HighBmwCar());
    }
};


int main(int argc, char** argv)
{
    Factory* factory = new BenzFactory();
    Car* specificCar = factory->createSpecificCar();
    HighCar* spcificHighCar = factory->createdSpecificHighCar();
   
    
    return 0;
}
```

